#' Preprocess input data for RSS analysis
#'
#' This function preprocesses summary statistics and LD data for RSS analysis.
#' It performs allele quality control, flipping alleles as necessary, and removes
#' specified regions from the analysis.
#'
#' @param sumstats A data frame containing summary statistics with columns "chrom", "pos", "A1", and "A2".
#' @param LD_data A list containing combined LD variants data that is generated by load_LD_matrix.
#' @param skip_region A character vector specifying regions to be skipped in the analysis (optional).
#'                    Each region should be in the format "chrom:start-end" (e.g., "1:1000000-2000000").
#'
#' @return A list containing the processed summary statistics and LD matrix.
#'   - sumstats: A data frame containing the processed summary statistics.
#'   - LD_mat: The processed LD matrix.
#'
#' @importFrom dplyr filter pull arrange
#' @importFrom tibble tibble
#' @importFrom tidyr separate
#' @importFrom magrittr %>%
#' @export
rss_basic_qc <- function(sumstats, LD_data, skip_region = NULL, remove_indels = FALSE) {
  # Check if required columns are present in sumstats
  required_cols <- c("chrom", "pos", "A1", "A2")
  missing_cols <- setdiff(required_cols, colnames(sumstats))
  if (length(missing_cols) > 0) {
    stop("Missing columns in sumstats: ", paste(missing_cols, collapse = ", "))
  }

  ref_variants <- LD_data$combined_LD_variants

  allele_flip <- allele_qc(sumstats, ref_variants,
    col_to_flip = c("beta", "z"),
    match_min_prop = 0, remove_dups = TRUE, remove_indels = remove_indels,
    remove_strand_ambiguous = TRUE
  )

  if (!is.null(skip_region)) {
    skip_table <- tibble(region = skip_region) %>%
      separate(region, into = c("chrom", "start", "end"), sep = "[-:]")

    skip_variant <- c()
    for (region_index in 1:nrow(skip_table)) {
      variant <- allele_flip$target_data_qced %>%
        filter(chrom == skip_table$chrom[region_index] &
          pos > skip_table$start[region_index] &
          pos < skip_table$end[region_index]) %>%
        pull(variant_id)
      skip_variant <- c(skip_variant, variant)
    }

    allele_flip$target_data_qced <- allele_flip$target_data_qced %>%
      filter(!(variant_id %in% skip_variant))
  }

  sumstats_processed <- allele_flip$target_data_qced %>% arrange(pos)

  # Align and subset LD by mapping core IDs (strip trailing build suffix) to exact LD IDs
  ld_mat <- LD_data$combined_LD_matrix
  ld_ids <- tryCatch(rownames(ld_mat), error = function(e) NULL)
  if (is.null(ld_ids)) {
    stop("LD matrix rownames are NULL; cannot align variant IDs.")
  }
  present <- sumstats_processed$variant_id %in% ld_ids
  if (sum(present) == 0) {
    strip_build <- function(x) sub("(:|_)b[0-9]+$", "", x)
    drop_chr <- function(x) sub("^chr", "", x)
    ld_core <- drop_chr(strip_build(ld_ids))
    ss_core <- drop_chr(strip_build(sumstats_processed$variant_id))
    map_idx <- match(ss_core, ld_core)
    remap <- !is.na(map_idx)
    if (sum(remap) > 0) {
      sumstats_processed$variant_id[remap] <- ld_ids[map_idx[remap]]
      present <- sumstats_processed$variant_id %in% ld_ids
    }
  }
  if (sum(present) == 0) {
    stop("No overlapping variants between sumstats and LD after alignment.")
  }

  LD_mat_processed <- LD_data$combined_LD_matrix[sumstats_processed$variant_id, sumstats_processed$variant_id, drop = FALSE]

  return(list(sumstats = sumstats_processed, LD_mat = LD_mat_processed))
}


#' Perform Quality Control based on SuSiE RSS
#'
#' This function performs quality control on summary statistics using SuSiE RSS.
#' It identifies and removes outliers based on z-score and LD matrix discrepancy correction.
#'
#' @param sumstats A data frame containing summary statistics with 'variant_id', 'z', and 'pos' columns.
#' @param LD_mat Numeric matrix representing the LD (linkage disequilibrium) matrix.
#' @param L Number of causal configurations to consider in the analysis.
#'
#' @return A list containing the quality-controlled summary statistics and updated LD matrix.
#'   - sumstats_qc: A data frame containing the quality-controlled summary statistics.
#'   - LD_mat_qc: The updated LD matrix excluding outlier variants.
#'
#' @details This function performs quality control on summary statistics using SuSiE RSS.
#'   It first extracts the z-scores from the `sumstats` data frame and performs SuSiE RSS analysis
#'   with discrepancy correction using the `susie_rss` function.
#'
#'   Next, it identifies outlier variants based on the results of the SuSiE RSS analysis.
#'   It removes the outlier variants from the summary statistics and updates the LD matrix accordingly.
#'
#'   Finally, it returns a list containing the quality-controlled summary statistics and the updated LD matrix.
#'
#' @importFrom susieR susie_rss
#' @export
susie_rss_qc <- function(sumstats, LD_mat, n = NULL, var_y = NULL, L = 10) {
  if (is.data.frame(sumstats)) {
    zScore <- sumstats$z
  } else if (is.vector(sumstats)) {
    zScore <- sumstats
  } else {
    stop("sumstats should either be a data frame with column z, or a vector of z-scores")
  }
  # Check that LD_mat dimensions match the length of zScore
  if (!is.matrix(LD_mat) || nrow(LD_mat) != ncol(LD_mat) || nrow(LD_mat) != length(zScore)) {
    stop("LD_mat must be a square matrix with dimensions equal to the length of zScore.")
  }
  result <- susie_rss(
    z = zScore, R = LD_mat, n = n, var_y = var_y, L = L,
    correct_zR_discrepancy = TRUE, track_fit = TRUE, max_iter = 100
  )

  ## Identify outlier variants
  if (!is.null(result$zR_outliers) & length(result$zR_outliers) != 0) {
    outlier <- result$zR_outliers
    sumstats_qc <- sumstats[-outlier, ]
    LD_extract_qc <- as.matrix(LD_mat)[-outlier, -outlier]
  } else {
    outlier <- NULL
    sumstats_qc <- sumstats
    LD_extract_qc <- as.matrix(LD_mat)
  }

  return(list(sumstats = sumstats_qc, LD_mat = LD_extract_qc, outlier_number = length(outlier)))
}

#' Perform Quality Control on Summary Statistics
#'
#' This function performs quality control on the processed summary statistics using the specified method.
#'
#' @param sumstats A data frame containing the processed summary statistics.
#' @param LD_data A list containing the combined LD variants data generated by load_LD_matrix.
#' @param method The quality control method to use. Options are "rss_qc", "dentist", or "slalom" (default: "rss_qc").
#'
#' @return A list containing the quality-controlled summary statistics and updated LD matrix.
#'   - sumstats_qc: The quality-controlled summary statistics data frame.
#'   - LD_mat_qc: The updated LD matrix after quality control.
#'
#' @details This function applies the specified quality control method to the processed summary statistics.
#'
#'   The available quality control methods are:
#'   - "rss_qc": Applies the RSS QC quality control procedure (Sun and Dong et al 2023+).
#'   - "dentist": Applies the DENTIST quality control procedure (Chen et al 2021).
#'   - "slalom": Applies the SLALOM quality control procedure.
#'
#'   The function returns the quality-controlled summary statistics along with the updated LD matrix.
#'
#' @examples
#' # Perform RSS quality control
#' qc_results <- summary_stats_qc(sumstats, LD_data, method = "rss_qc")
#'
#' @export
summary_stats_qc <- function(sumstats, LD_data, n = NULL, var_y = NULL, method = c("rss_qc", "dentist", "slalom")) {
  # assuming sumstats has been allele QC-ed, using rss_basic_qc() function
  LD_extract <- LD_data$combined_LD_matrix[sumstats$variant_id, sumstats$variant_id, drop = FALSE]
  if (method == "rss_qc") {
    qc_results <- susie_rss_qc(sumstats, LD_extract, n = n, var_y = var_y)
    sumstats_qc <- qc_results$sumstats
    LD_mat_qc <- qc_results$LD_mat
    outlier_number <- qc_results$outlier_number
  } else if (method == "dentist") {
    qc_results <- dentist_single_window(sumstats$z, LD_extract, nSample = n, duprThreshold = 0.99)
    keep_index <- qc_results %>%
      mutate(index = row_number()) %>%
      filter(!outlier) %>%
      pull(index)
    sumstats_qc <- sumstats[keep_index, , drop = FALSE]
    LD_mat_qc <- LD_extract[sumstats_qc$variant_id, sumstats_qc$variant_id, drop = FALSE]
    outlier_number <- nrow(sumstats) - nrow(sumstats_qc)
  } else if (method == "slalom") {
    qc_results <- slalom(zScore = sumstats$z, LD_mat = LD_extract)
    keep_index <- qc_results$data %>%
      mutate(index = row_number()) %>%
      filter(!outliers) %>%
      pull(index)
    sumstats_qc <- sumstats[keep_index, , drop = FALSE]
    LD_mat_qc <- LD_extract[sumstats_qc$variant_id, sumstats_qc$variant_id, drop = FALSE]
    outlier_number <- nrow(sumstats) - nrow(sumstats_qc)
  } else {
    stop("Invalid quality control method specified. Available methods are: 'rss_qc', 'dentist', 'slalom'.")
  }

  return(list(sumstats = sumstats_qc, LD_mat = LD_mat_qc, outlier_number = outlier_number))
}
